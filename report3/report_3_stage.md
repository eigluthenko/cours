---
## Front matter
title: "Отчет о прохождении 3 этапа внешних курсов"
subtitle: "Продвинутые темы"
author: "Глущенко Евгений Игоревич, НКАбд-02-23"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Ознакомиться с функционалом операционной системы Linux.

# Задание

Просмотреть видео и на основе полученной информации пройти тестовые задания.

# Теоретическое введение

Линукс - в части случаев GNU/Linux — семейство Unix-подобных операционных систем на базе ядра Linux, включающих тот или иной набор утилит и программ проекта GNU, и, возможно, другие компоненты. Как и ядро Linux, системы на его основе, как правило, создаются и распространяются в соответствии с моделью разработки свободного и открытого программного обеспечения. Linux-системы распространяются в основном бесплатно в виде различных дистрибутивов — в форме, готовой для установки и удобной для сопровождения и обновлений, — и имеющих свой набор системных и прикладных компонентов, как свободных, так и проприетарных. 

# Выполнение лабораторной работы

3 Этап: (рис. @fig:001, @fig:002, @fig:003, @fig:004, @fig:005, @fig:006, @fig:007, @fig:008, @fig:009, @fig:010, @fig:011, @fig:012, @fig:013, @fig:014, @fig:015, @fig:016, @fig:017, @fig:018, @fig:019, @fig:020, @fig:021, @fig:022, @fig:023, @fig:024, @fig:025, @fig:026, @fig:027, @fig:028, @fig:029, @fig:030, @fig:031, @fig:032, @fig:033, @fig:034, @fig:035, @fig:036, @fig:037, @fig:038, @fig:039, @fig:040, @fig:041).

![Задание 1](image/1.png){#fig:001 width=70%}

У редактора vim есть туториал, который позволяет разобраться с командами, необходимыми для стандартной работы. 
- ZQ - выйти без сохранения
- :q! - выйти без сохранения
- ZZ - записать файл и выйти (если файл не изменяли, то записываться он не будет)
- :wq - записать файл и выйти
- :x - записать файл и выйти
- :w<CR> - записать файл
- :sav filename<CR> - "сохранить как"
- :w filename<CR> - "сохранить как"
- :w!<CR> - записать файл



![Задание 2](image/2.png){#fig:002 width=70%}

Нельзя нажимая только на w  переместить курсор на "."


![Задание 3](image/3.png){#fig:003 width=70%}

d2wwywPp

d2w&bifour four <<Esc>>

xxxxxxxxwywPp

ddithree four four four five <<Esc>>

- $ — в конец текущей строки;
- w — на слово вправо;
- b — на слово влево;
- i — начать ввод перед курсором;
- p — вставка содержимого неименнованного буфера под курсором;
- P — вставка содержимого неименованного буфера перед курсором;
- yy (также Y) — копирование текущей строки в неименованный буфер;
- y<число>y — копирование числа строк начиная с текущей в неименованный буфер;

![Задание 4](image/4.png){#fig:004 width=70%}

Поиск и замена в редакторе работают так:

`:{пределы}s/{что заменяем}/{на что заменяем}/{опции}`

Для замены во всем файле мы можем использовать  %.


![Задание 5](image/5.png){#fig:005 width=70%}

Режим выдеелния не открывается с помощью :visual
Режим выделения не открывается из любого другого режима по нажатию "v"


![Задание 6](image/6.png){#fig:006 width=70%}

Только из набора С потому что у каждой оболочки свой буфер, который при выходе из нее буде записываться в файл истории.

![Задание 7](image/7.png){#fig:007 width=70%}

`/home/bi/file1.txt` - потому что в этой директории мы создаем новый файл, а после его создания мы переходим в другую папку.


![Задание 8](image/8.png){#fig:008 width=70%}

Имя не должно начинаться с цифры, не может иметь в своем составе специальные символы кроме "_"

![Задание 9](image/9.png){#fig:009 width=70%}

`$ echo опции строка`
Эта команда выводит переданные в качестве аргументов строки в стандартный вывод. Обычно она используется в оболочечных сценариях для отображения сообщений или результатов выполнения других команд.

var1=$1, var2=$2 - обозначение переменных

echo "Arguments are: \$1=$var1 \$2=$var2"` - строка печати.

![Задание 10](image/10.png){#fig:010 width=70%}

- $0 - имя скрипта
- $# - вернет количество аргументов
- -ge - больше или равно
- -n <string> - не пустая строка.


![Задание 11](image/11.png){#fig:011 width=70%}

-lt - меньше
-gt - больше
-eq - равно

3 > 5 - не верно, 3 < 3 - не верно, 3 = 4 - не верно.

5 > 5 - не верно, 5 < 3 - не верно, 5 = 4 - не верно.



![Задание 12](image/12.png){#fig:012 width=70%}

1. Если "число" равно одному, то вывести " "число" студент ".
2. Если "число" больше одного, но меньше или рано 5, то вывести " "число" студенты ".
3. Если "число" больше пяти, то вывести "Много студентов".
4. Если ничего не подходит, то вывести "Нет судентов".

![Задание 13](image/13.png){#fig:013 width=70%}

- (Start)
- a > c нет (Finish) 
- (Start)
- , > c нет (Finish) 
- (Start)
- b > c нет (Finish) 
- (Start)
- , > c нет (Finish) 
- (Start)
- c_d > c да


![Задание 14](image/14.png){#fig:015 width=70%}

#!/bin/bash
while true
do
    echo "enter your name:"
    read name
    [[ -z $name ]] && break
    echo "enter your age:"
    read age
    [[ $age -eq 0 ]] && break

    [[ $age -le 16 ]] && group="child"
    [[ $age -gt 16 && $age -le 25 ]] && group="youth"
    [[ $age -gt 25 ]] && group="adult"
    echo "$name, your group is $group"
done
echo "bye"



Это оболочный скрипт на языке Bash, который запрашивает у пользователя его имя и возраст, а затем классифицирует его в одну из трех групп: "ребенок", "молодежь" или "взрослый" в зависимости от возраста. Вот пошаговое объяснение скрипта:

1. #!/bin/bash: Это так называемый шибанг, который указывает, что скрипт должен выполняться с помощью интерпретатора Bash.

2. Цикл while: Цикл while будет выполняться до тех пор, пока условие в нем верно. В данном случае условие всегда истинно (true), поэтому цикл будет выполняться бесконечно, пока пользователь не выполнит команду break.

3. echo "enter your name:": Выводит на экран запрос ввести имя.

4. read name: Считывает введенное пользователем имя и сохраняет его в переменной name.

5. [[ -z $name ]] && break: Проверяет, пуста ли переменная name. Если она пуста (т.е. пользователь нажал Enter без ввода имени), цикл while прерывается с помощью команды break.

6. echo "enter your age:": Выводит на экран запрос ввести возраст.

7. read age: Считывает введенный пользователем возраст и сохраняет его в переменной age.

8. [[ $age -eq 0 ]] && break: Проверяет, равен ли возраст 0. Если возраст равен 0 (т.е. пользователь ввел 0), цикл while прерывается с помощью команды break.

9. Далее скрипт определяет группу, к которой относится пользователь, на основе его возраста:
   - [[ $age -le 16 ]] && group="child": Если возраст меньше или равен 16, группа устанавливается в "child".
   - [[ $age -gt 16 && $age -le 25 ]] && group="youth": Если возраст больше 16 и меньше или равен 25, группа устанавливается в "youth".
   - [[ $age -gt 25 ]] && group="adult": Если возраст больше 25, группа устанавливается в "adult".

10. echo "$name, your group is $group": Выводит на экран сообщение, содержащее имя пользователя и его группу.

11. После выхода из цикла while скрипт выводит на экран "bye".



![Задание 15](image/15.png){#fig:016 width=70%}

1. a = $a
2. а+=b тоже самое что и a=a+b

![Задание 16](image/16.png){#fig:017 width=70%}

Выведет путь до директории, в которую мы перешли, так как "pwd" - это команда

![Задание 16_2](image/16_2.png){#fig:018 width=70%}

`programm`  выполняет стандартный вывод в терминал. И нам нужно настроить вывод в файл.

![Задание 17](image/17.png){#fig:019 width=70%}

Локальная переменная является пустой строкой, а вторая переменная представляет собой сумму арифметической прогрессии от 1 до 10, которая равна 55. При умножении этой суммы на 2 получаем результат 110.

![Задание 20](image/22.png){#fig:024 width=70%}

-iname ищет без учета регистра, а -name в точности как в запросе. Звездочка стоит после слова - это значит после слова может быть сколько угодно символов.

![Задание 21](image/23.png){#fig:025 width=70%}

find [path] [expression]

где: path - это путь к директории, в которой нужно выполнить поиск файлов (по умолчанию, поиск производится в текущей директории и всех ее поддиректориях).


![Задание 22](image/24.png){#fig:026 width=70%}

Текущий каталог - это depth=1, а остальное считается просто:

/home/bi   -> depth=1

/home/bi/dir1   -> depth=2

/home/bi/dir1/dir2   -> depth=3


![Задание 23](image/25.png){#fig:027 width=70%}

Print NUM lines of trailing context after/before matching lines
"matching lines". Если в последовательных строках текста (например, со 2-й по 100-ю) обнаружено совпадение, то вывод контекста будет производиться до и после всей группы этих строк, а не до и после каждой отдельной строки в данной группе.

![Задание 24](image/26.png){#fig:028 width=70%}

Написал программу и пргнал ее, видно на скринкасте.

![Задание 25](image/27.png){#fig:030 width=70%}

The -n option disables the automatic printing, which means the lines you don't specifically tell it to print do not get printed, and lines you do explicitly tell it to print (e.g. with p) get printed only once. 


![Задание 26](image/28.png){#fig:031 width=70%}

Из-за наличия запятой без пробела после аббревиатуры ABBA ("ABBA,") она отличается от других аббревиатур, которые соответствуют следующим шаблонам: [ XX ] или [ XXX ] (и более). Чтобы привести ABBA к указанному формату, необходимо добавить пробел внутри квадратных скобок с обеих сторон: [ ABBA ].


![Задание 27](image/29.png){#fig:032 width=70%}

-persist lets plot windows survive after main gnuplot program exits. 


![Задание 28](image/30.png){#fig:033 width=70%}

`plot 'data.csv' using 1:2` даст ошибку:

`warning: Skipping data file with no valid points ^ x range is invalid`

Вероятной причиной необычного поведения парсера является спецификация формата CSV, которая допускает наличие строк, где значения в столбцах разделяются запятыми.

![Задание 29](image/31.png){#fig:034 width=70%}

Процесс установки подписей в заданной последовательности происходит следующим образом:

1. Формируется команда установки подписей.
2. В скобках указывается подпись, состоящая из текста задания и переменной с координатой, разделенных пробелом и запятой.
3. Этот процесс повторяется для каждой переменной, разделяя их запятыми (кроме последней переменной).

![Задание 30](image/32.png){#fig:035 width=70%}

1. График строится командой "splot x2+y2".
2. Чтобы вращать объект в противоположную сторону, необходимо изменить команду "zrot=(zrot+10)%360" на "zrot=(zrot+350)%360".
3. Для более частой перерисовки нужно уменьшить паузу в команде "pause", например: "pause 0.1".

![Задание 31](image/33.png){#fig:036 width=70%}


r - чтение;
w - запись;
x - выполнение;
s - выполнение  от имени суперпользователя (дополнительный);
u - владелец файла;
g - группа файла;
o - все остальные пользователи;
0 - никаких прав;
1 - только выполнение;
2 - только запись;
3 - выполнение и запись;
4 -  только чтение;
5 - чтение и выполнение;
6 - чтение и запись;
7 - чтение запись и выполнение.

![Задание 32](image/34.png){#fig:037 width=70%}

![Задание 33](image/35.png){#fig:038 width=70%}

wc -l <filename> вывести количество строк
wc -c <filename> вывести количество байт
wc -m <filename> вывести количество символов
wc -L <filename> вывести длину самой длинной строки
wc -w <filename> вывести количество слов

![Задание 34](image/36.png){#fig:039 width=70%}

-h, --human-readable
    print sizes in human readable format (e.g., 1K 234M 2G)
    
-s, --summarize
    display only a total for each argument 

![Задание 35](image/37.png){#fig:040 width=70%}

Самая короткая команда, которая создаст три директории от dir1 до dir3. 

# Сертификат

![Сертификат](image/сертификат.png){#fig:041 width=70%}

# Выводы

Я просмотрела курс и освежила в памяти навыки работы с более сложными командами в Линукс.

# Список литературы{.unnumbered}

1. Введение в Linux

::: {#refs}
:::
